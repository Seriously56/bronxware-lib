local cloneref = (cloneref or clonereference or function(instance: any) return instance end)
local InputService: UserInputService = cloneref(game:GetService('UserInputService'));
local TextService: TextService = cloneref(game:GetService('TextService'));
local CoreGui: CoreGui = cloneref(game:GetService('CoreGui'));
local Teams: Teams = cloneref(game:GetService('Teams'));
local Players: Players = cloneref(game:GetService('Players'));
local RunService: RunService = cloneref(game:GetService('RunService'));
local TweenService: TweenService = cloneref(game:GetService('TweenService'));
local RenderStepped = RunService.RenderStepped;
local LocalPlayer = Players.LocalPlayer;
local Mouse = LocalPlayer:GetMouse();

local DrawingLib = typeof(Drawing) == "table" and Drawing or { drawing_replaced = true };
local ProtectGui = protectgui or (function() end);
local GetHUI = gethui or (function() return CoreGui end);

local IsBadDrawingLib = false;

-- Modern Color Scheme
local ModernColors = {
    Primary = Color3.fromRGB(25, 25, 35),
    Secondary = Color3.fromRGB(35, 35, 50),
    Accent = Color3.fromRGB(0, 150, 255),
    AccentDark = Color3.fromRGB(0, 100, 200),
    Text = Color3.fromRGB(240, 240, 240),
    TextSecondary = Color3.fromRGB(180, 180, 200),
    Success = Color3.fromRGB(0, 200, 100),
    Warning = Color3.fromRGB(255, 150, 0),
    Error = Color3.fromRGB(255, 50, 50),
    Border = Color3.fromRGB(60, 60, 80),
    Hover = Color3.fromRGB(45, 45, 65)
}

local function SafeParentUI(Instance: Instance, Parent: Instance | () -> Instance)
    if not pcall(function()
        local DestinationParent
        if typeof(Parent) == "function" then
            DestinationParent = Parent()
        else
            DestinationParent = Parent
        end

        Instance.Parent = DestinationParent
    end) then
        Instance.Parent = LocalPlayer:WaitForChild("PlayerGui", math.huge)
    end
end

local function ParentUI(UI: Instance, SkipHiddenUI: boolean?)
    if SkipHiddenUI then
        SafeParentUI(UI, CoreGui)
        return
    end

    pcall(ProtectGui, UI)
    SafeParentUI(UI, GetHUI)
end

local ScreenGui = Instance.new('ScreenGui');
ScreenGui.ZIndexBehavior = Enum.ZIndexBehavior.Global;
ScreenGui.DisplayOrder = 999;
ScreenGui.ResetOnSpawn = false;
ParentUI(ScreenGui);

local ModalScreenGui = Instance.new("ScreenGui");
ModalScreenGui.DisplayOrder = 999;
ModalScreenGui.ResetOnSpawn = false;
ParentUI(ModalScreenGui, true);

local ModalElement = Instance.new("TextButton");
ModalElement.BackgroundTransparency = 1
ModalElement.Modal = false
ModalElement.Size = UDim2.fromScale(0, 0)
ModalElement.Text = ""
ModalElement.ZIndex = -999
ModalElement.Parent = ModalScreenGui

local Toggles = {};
local Options = {};
local Labels = {};
local Buttons = {};

getgenv().Linoria = {
    Toggles = Toggles;
    Options = Options;
    Labels = Labels;
    Buttons = Buttons;
}

getgenv().Toggles = Toggles;
getgenv().Options = Options;
getgenv().Labels = Labels;
getgenv().Buttons = Buttons;

local LibraryMainOuterFrame = nil;
local Library = {
    Registry = {};
    RegistryMap = {};

    HudRegistry = {};

    FontColor = ModernColors.Text;
    MainColor = ModernColors.Primary;
    BackgroundColor = ModernColors.Secondary;

    AccentColor = ModernColors.Accent;
    DisabledAccentColor = Color3.fromRGB(100, 100, 120);

    OutlineColor = ModernColors.Border;
    DisabledOutlineColor = Color3.fromRGB(80, 80, 100);

    DisabledTextColor = Color3.fromRGB(140, 140, 160);

    RiskColor = ModernColors.Error;

    Black = Color3.new(0, 0, 0);
    Font = Enum.Font.Gotham,

    OpenedFrames = {};
    DependencyBoxes = {};

    UnloadSignals = {};
    Signals = {};
    ScreenGui = ScreenGui;
    
    ActiveTab = nil;
    Toggled = false;

    IsMobile = false;
    DevicePlatform = Enum.Platform.None;

    CanDrag = true;
    CantDragForced = false;

    NotifySide = "Left";
    ShowCustomCursor = true;
    ShowToggleFrameInKeybinds = true;
    NotifyOnError = false;

    VideoLink = "";
    TotalTabs = 0;

    Toggles = Toggles;
    Options = Options;
    Labels = Labels;
    Buttons = Buttons;
};

pcall(function() Library.DevicePlatform = InputService:GetPlatform(); end);
Library.IsMobile = (Library.DevicePlatform == Enum.Platform.Android or Library.DevicePlatform == Enum.Platform.IOS);
Library.MinSize = if Library.IsMobile then Vector2.new(550, 200) else Vector2.new(550, 300);

local RainbowStep = 0
local Hue = 0
local DPIScale = 1

table.insert(Library.Signals, RenderStepped:Connect(function(Delta)
    RainbowStep = RainbowStep + Delta

    if RainbowStep >= (1 / 60) then
        RainbowStep = 0;

        Hue = Hue + (1 / 400);

        if Hue > 1 then
            Hue = 0;
        end;

        Library.CurrentRainbowHue = Hue;
        Library.CurrentRainbowColor = Color3.fromHSV(Hue, 0.8, 1);
    end;
end));

local function ApplyDPIScale(Position)
    return UDim2.new(Position.X.Scale, Position.X.Offset * DPIScale, Position.Y.Scale, Position.Y.Offset * DPIScale);
end;

local function ApplyTextScale(TextSize)
    return TextSize * DPIScale;
end;

local function GetTableSize(t)
    local n = 0
    for _, _ in pairs(t) do
        n = n + 1
    end
    return n;
end;

local function GetPlayers(ExcludeLocalPlayer, ReturnInstances)
    local PlayerList = Players:GetPlayers();

    if ExcludeLocalPlayer then
        local Idx = table.find(PlayerList, LocalPlayer);

        if Idx then
            table.remove(PlayerList, Idx);
        end
    end

    table.sort(PlayerList, function(Player1, Player2)
        return Player1.Name:lower() < Player2.Name:lower();
    end)

    if ReturnInstances == true then
        return PlayerList;
    end;

    local FixedPlayerList = {};
    for _, player in next, PlayerList do
        FixedPlayerList[#FixedPlayerList + 1] = player.Name;
    end;

    return FixedPlayerList;
end;

local function GetTeams(ReturnInstances)
    local TeamList = Teams:GetTeams();

    table.sort(TeamList, function(Team1, Team2)
        return Team1.Name:lower() < Team2.Name:lower();
    end)

    if ReturnInstances == true then
        return TeamList;
    end;

    local FixedTeamList = {};
    for _, team in next, TeamList do
        FixedTeamList[#FixedTeamList + 1] = team.Name;
    end;

    return FixedTeamList;
end;

-- Modern rounded corners function
local function ApplyModernCorners(instance, cornerRadius)
    local corner = Instance.new("UICorner")
    corner.CornerRadius = UDim.new(0, cornerRadius or 8)
    corner.Parent = instance
    return corner
end

-- Modern stroke function
local function ApplyModernStroke(instance, thickness, color)
    local stroke = Instance.new("UIStroke")
    stroke.Thickness = thickness or 1
    stroke.Color = color or ModernColors.Border
    stroke.ApplyStrokeMode = Enum.ApplyStrokeMode.Border
    stroke.Parent = instance
    return stroke
end

-- Enhanced Create function with modern styling
function Library:CreateModern(Class, Properties)
    local instance = self:Create(Class, Properties)
    
    if Class == "Frame" and not Properties.BackgroundTransparency then
        ApplyModernCorners(instance, Properties.CornerRadius or 8)
        if not Properties.NoStroke then
            ApplyModernStroke(instance, Properties.StrokeThickness or 1)
        end
    elseif Class == "TextButton" and not Properties.BackgroundTransparency then
        ApplyModernCorners(instance, Properties.CornerRadius or 6)
        if not Properties.NoStroke then
            ApplyModernStroke(instance, Properties.StrokeThickness or 1)
        end
    elseif Class == "TextBox" then
        ApplyModernCorners(instance, 6)
        ApplyModernStroke(instance, 1)
    end
    
    return instance
end

function Library:SetDPIScale(value: number) 
    assert(type(value) == "number", "Expected type number for DPI scale but got " .. typeof(value))
    
    DPIScale = value / 100;
    Library.MinSize = (if Library.IsMobile then Vector2.new(550, 200) else Vector2.new(550, 300)) * DPIScale;
end;

function Library:SafeCallback(Func, ...)
    if not (Func and typeof(Func) == "function") then
        return
    end

    local run = function(func, ...)
        local Success, Response = pcall(func, ...)
        if Success then
            return Response
        end
    
        local Traceback = debug.traceback():gsub("\n", " ")
        local _, i = Traceback:find(":%d+ ")
        Traceback = Traceback:sub(i + 1):gsub(" :", ":")
    
        task.defer(error, Response .. " - " .. Traceback)
        if Library.NotifyOnError then
            Library:Notify(Response)
        end
    end;

    task.spawn(run, Func, ...);
end;

function Library:AttemptSave()
    if (not Library.SaveManager) then return end;
    Library.SaveManager:Save();
end;

function Library:Create(Class, Properties)
    local _Instance = Class;

    if typeof(Class) == "string" then
        _Instance = Instance.new(Class);
    end;

    for Property, Value in next, Properties do
        if (Property == "Size" or Property == "Position") then
            Value = ApplyDPIScale(Value);
        elseif Property == "TextSize" then
            Value = ApplyTextScale(Value);
        end;

        local success, err = pcall(function()
            _Instance[Property] = Value;
        end);

        if (not success) then
            warn(err);
        end;
    end;

    return _Instance;
end;

function Library:ApplyTextStroke(Inst)
    Inst.TextStrokeTransparency = 1;

    return Library:Create('UIStroke', {
        Color = Color3.new(0, 0, 0);
        Thickness = 1;
        LineJoinMode = Enum.LineJoinMode.Miter;
        Parent = Inst;
    });
end;

function Library:CreateLabel(Properties, IsHud)
    local _Instance = Library:Create('TextLabel', {
        BackgroundTransparency = 1;
        Font = Library.Font;
        TextColor3 = Library.FontColor;
        TextSize = 16;
        TextStrokeTransparency = 0;
    });

    Library:ApplyTextStroke(_Instance);

    Library:AddToRegistry(_Instance, {
        TextColor3 = 'FontColor';
    }, IsHud);

    return Library:Create(_Instance, Properties);
end;

function Library:MakeDraggable(Instance, Cutoff, IsMainWindow)
    Instance.Active = true;

    if Library.IsMobile == false then
        Instance.InputBegan:Connect(function(Input)
            if Input.UserInputType == Enum.UserInputType.MouseButton1 then
                if IsMainWindow == true and Library.CantDragForced == true then
                    return;
                end;
           
                local ObjPos = Vector2.new(
                    Mouse.X - Instance.AbsolutePosition.X,
                    Mouse.Y - Instance.AbsolutePosition.Y
                );

                if ObjPos.Y > (Cutoff or 40) then
                    return;
                end;

                while InputService:IsMouseButtonPressed(Enum.UserInputType.MouseButton1) do
                    Instance.Position = UDim2.new(
                        0,
                        Mouse.X - ObjPos.X + (Instance.Size.X.Offset * Instance.AnchorPoint.X),
                        0,
                        Mouse.Y - ObjPos.Y + (Instance.Size.Y.Offset * Instance.AnchorPoint.Y)
                    );

                    RenderStepped:Wait();
                end;
            end;
        end);
    else
        local Dragging, DraggingInput, DraggingStart, StartPosition;

        InputService.TouchStarted:Connect(function(Input)
            if IsMainWindow == true and Library.CantDragForced == true then
                Dragging = false
                return;
            end

            if not Dragging and Library:MouseIsOverFrame(Instance, Input) and (IsMainWindow == true and (Library.CanDrag == true and Library.Window.Holder.Visible == true) or true) then
                DraggingInput = Input;
                DraggingStart = Input.Position;
                StartPosition = Instance.Position;

                local OffsetPos = Input.Position - DraggingStart;
                if OffsetPos.Y > (Cutoff or 40) then
                    Dragging = false;
                    return;
                end;

                Dragging = true;
            end;
        end);
        InputService.TouchMoved:Connect(function(Input)
            if IsMainWindow == true and Library.CantDragForced == true then
                Dragging = false;
                return;
            end

            if Input == DraggingInput and Dragging and (IsMainWindow == true and (Library.CanDrag == true and Library.Window.Holder.Visible == true) or true) then
                local OffsetPos = Input.Position - DraggingStart;

                Instance.Position = UDim2.new(
                    StartPosition.X.Scale,
                    StartPosition.X.Offset + OffsetPos.X,
                    StartPosition.Y.Scale,
                    StartPosition.Y.Offset + OffsetPos.Y
                );
            end;
        end);
        InputService.TouchEnded:Connect(function(Input)
            if Input == DraggingInput then 
                Dragging = false;
            end;
        end);
    end;
end;

function Library:MakeDraggableUsingParent(Instance, Parent, Cutoff, IsMainWindow)
    Instance.Active = true;

    if Library.IsMobile == false then
        Instance.InputBegan:Connect(function(Input)
            if Input.UserInputType == Enum.UserInputType.MouseButton1 then
                if IsMainWindow == true and Library.CantDragForced == true then
                    return;
                end;
  
                local ObjPos = Vector2.new(
                    Mouse.X - Parent.AbsolutePosition.X,
                    Mouse.Y - Parent.AbsolutePosition.Y
                );

                if ObjPos.Y > (Cutoff or 40) then
                    return;
                end;

                while InputService:IsMouseButtonPressed(Enum.UserInputType.MouseButton1) do
                    Parent.Position = UDim2.new(
                        0,
                        Mouse.X - ObjPos.X + (Parent.Size.X.Offset * Parent.AnchorPoint.X),
                        0,
                        Mouse.Y - ObjPos.Y + (Parent.Size.Y.Offset * Parent.AnchorPoint.Y)
                    );

                    RenderStepped:Wait();
                end;
            end;
        end);
    else  
        Library:MakeDraggable(Parent, Cutoff, IsMainWindow)
    end;
end;

function Library:MakeResizable(Instance, MinSize)
    if Library.IsMobile then
        return;
    end;

    Instance.Active = true;
    
    local ResizerImage_Size = 25 * DPIScale;
    local ResizerImage_HoverTransparency = 0.5;

    local Resizer = Library:Create('Frame', {
        SizeConstraint = Enum.SizeConstraint.RelativeXX;
        BackgroundColor3 = Color3.new(0, 0, 0);
        BackgroundTransparency = 1;
        BorderSizePixel = 0;
        Size = UDim2.new(0, 30, 0, 30);
        Position = UDim2.new(1, -30, 1, -30);
        Visible = true;
        ClipsDescendants = true;
        ZIndex = 1;
        Parent = Instance;
    });

    local ResizerImage = Library:Create('ImageButton', {
        BackgroundColor3 = Library.AccentColor;
        BackgroundTransparency = 1;
        BorderSizePixel = 0;
        Size = UDim2.new(2, 0, 2, 0);
        Position = UDim2.new(1, -30, 1, -30);
        ZIndex = 2;
        Parent = Resizer;
    });

    local ResizerImageUICorner = Library:Create('UICorner', {
        CornerRadius = UDim.new(0.5, 0);
        Parent = ResizerImage;
    });

    Library:AddToRegistry(ResizerImage, { BackgroundColor3 = 'AccentColor'; });

    Resizer.Size = UDim2.fromOffset(ResizerImage_Size, ResizerImage_Size);
    Resizer.Position = UDim2.new(1, -ResizerImage_Size, 1, -ResizerImage_Size);
    MinSize = MinSize or Library.MinSize;

    local OffsetPos;
    Resizer.Parent = Instance;

    local function FinishResize(Transparency)
        ResizerImage.Position = UDim2.new();
        ResizerImage.Size = UDim2.new(2, 0, 2, 0);
        ResizerImage.Parent = Resizer;
        ResizerImage.BackgroundTransparency = Transparency;
        ResizerImageUICorner.Parent = ResizerImage;
        OffsetPos = nil;
    end;

    ResizerImage.MouseButton1Down:Connect(function()
        if not OffsetPos then
            OffsetPos = Vector2.new(Mouse.X - (Instance.AbsolutePosition.X + Instance.AbsoluteSize.X), Mouse.Y - (Instance.AbsolutePosition.Y + Instance.AbsoluteSize.Y));

            ResizerImage.BackgroundTransparency = 1
            ResizerImage.Size = UDim2.fromOffset(Library.ScreenGui.AbsoluteSize.X, Library.ScreenGui.AbsoluteSize.Y);
            ResizerImage.Position = UDim2.new();
            ResizerImageUICorner.Parent = nil;
            ResizerImage.Parent = Library.ScreenGui;
        end;
    end);

    ResizerImage.MouseMoved:Connect(function()
        if OffsetPos then		
            local MousePos = Vector2.new(Mouse.X - OffsetPos.X, Mouse.Y - OffsetPos.Y);
            local FinalSize = Vector2.new(math.clamp(MousePos.X - Instance.AbsolutePosition.X, MinSize.X, math.huge), math.clamp(MousePos.Y - Instance.AbsolutePosition.Y, MinSize.Y, math.huge));
            Instance.Size = UDim2.fromOffset(FinalSize.X, FinalSize.Y);
        end;
    end);

    ResizerImage.MouseEnter:Connect(function()
        FinishResize(ResizerImage_HoverTransparency);	
    end);

    ResizerImage.MouseLeave:Connect(function()
        FinishResize(1);
    end);

    ResizerImage.MouseButton1Up:Connect(function()
        FinishResize(ResizerImage_HoverTransparency);
    end);
end;

function Library:AddToolTip(InfoStr, DisabledInfoStr, HoverInstance)
    InfoStr = typeof(InfoStr) == "string" and InfoStr or nil;
    DisabledInfoStr = typeof(DisabledInfoStr) == "string" and DisabledInfoStr or nil;

    local Tooltip = Library:CreateModern('Frame', {
        BackgroundColor3 = Library.MainColor;
        BorderColor3 = Library.OutlineColor;
        ZIndex = 100;
        Parent = Library.ScreenGui;
        Visible = false,
        CornerRadius = 6
    });

    ApplyModernStroke(Tooltip, 1, Library.AccentColor)

    local Label = Library:CreateLabel({
        Position = UDim2.fromOffset(8, 6);
        TextSize = 13;
        Text = InfoStr;
        TextColor3 = Library.FontColor;
        TextXAlignment = Enum.TextXAlignment.Left;
        ZIndex = Tooltip.ZIndex + 1;
        Parent = Tooltip;
    });

    Library:AddToRegistry(Tooltip, {
        BackgroundColor3 = 'MainColor';
        BorderColor3 = 'OutlineColor';
    });

    Library:AddToRegistry(Label, {
        TextColor3 = 'FontColor',
    });

    local TooltipTable = {
        Tooltip = Tooltip;
        Disabled = false;
        Signals = {};
    }
    local IsHovering = false

    local function UpdateText(Text)
        if Text == nil then return end
        local X, Y = Library:GetTextBounds(Text, Library.Font, 13 * DPIScale);
        Label.Text = Text;
        Tooltip.Size = UDim2.fromOffset(X + 16, Y + 12);
        Label.Size = UDim2.fromOffset(X, Y);
    end
    UpdateText(InfoStr);

    table.insert(TooltipTable.Signals, HoverInstance.MouseEnter:Connect(function()
        if Library:MouseIsOverOpenedFrame() then
            Tooltip.Visible = false
            return
        end

        if not TooltipTable.Disabled then
            if InfoStr == nil or InfoStr == "" then
                Tooltip.Visible = false
                return
            end
            if Label.Text ~= InfoStr then UpdateText(InfoStr); end
        else
            if DisabledInfoStr == nil or DisabledInfoStr == "" then
                Tooltip.Visible = false
                return
            end
            if Label.Text ~= DisabledInfoStr then UpdateText(DisabledInfoStr); end
        end

        IsHovering = true
        Tooltip.Position = UDim2.fromOffset(Mouse.X + 15, Mouse.Y + 12)
        Tooltip.Visible = true

        while IsHovering do
            if TooltipTable.Disabled == true and DisabledInfoStr == nil then break end
            RunService.Heartbeat:Wait()
            Tooltip.Position = UDim2.fromOffset(Mouse.X + 15, Mouse.Y + 12)
        end

        IsHovering = false
        Tooltip.Visible = false
    end))

    table.insert(TooltipTable.Signals, HoverInstance.MouseLeave:Connect(function()
        IsHovering = false
        Tooltip.Visible = false
    end))
    
    if LibraryMainOuterFrame then
        table.insert(TooltipTable.Signals, LibraryMainOuterFrame:GetPropertyChangedSignal("Visible"):Connect(function()
            if LibraryMainOuterFrame.Visible == false then
                IsHovering = false
                Tooltip.Visible = false
            end
        end))
    end

    function TooltipTable:Destroy()
        Tooltip:Destroy();
        for Idx = #TooltipTable.Signals, 1, -1 do
            local Connection = table.remove(TooltipTable.Signals, Idx);
            Connection:Disconnect();
        end
    end

    return TooltipTable
end

function Library:OnHighlight(HighlightInstance, Instance, Properties, PropertiesDefault, condition)
    local function undoHighlight()
        local Reg = Library.RegistryMap[Instance];
        for Property, ColorIdx in next, PropertiesDefault do
            Instance[Property] = Library[ColorIdx] or ColorIdx;
            if Reg and Reg.Properties[Property] then
                Reg.Properties[Property] = ColorIdx;
            end;
        end;
    end
    local function doHighlight()
        if condition and not condition() then undoHighlight() return end
        local Reg = Library.RegistryMap[Instance];
        for Property, ColorIdx in next, Properties do
            Instance[Property] = Library[ColorIdx] or ColorIdx;
            if Reg and Reg.Properties[Property] then
                Reg.Properties[Property] = ColorIdx;
            end;
        end;
    end

    HighlightInstance.MouseEnter:Connect(function()
        doHighlight()
    end)
    HighlightInstance.MouseMoved:Connect(function()
        doHighlight()
    end)
    HighlightInstance.MouseLeave:Connect(function()
        undoHighlight()
    end)
end;

function Library:MouseIsOverOpenedFrame(Input)
    local Pos = Mouse;
    if Library.IsMobile and Input then 
        Pos = Input.Position;
    end;

    for Frame, _ in next, Library.OpenedFrames do
        local AbsPos, AbsSize = Frame.AbsolutePosition, Frame.AbsoluteSize;
        if Pos.X >= AbsPos.X and Pos.X <= AbsPos.X + AbsSize.X
            and Pos.Y >= AbsPos.Y and Pos.Y <= AbsPos.Y + AbsSize.Y then
            return true;
        end;
    end;
end;

function Library:MouseIsOverFrame(Frame, Input)
    local Pos = Mouse;
    if Library.IsMobile and Input then 
        Pos = Input.Position;
    end;
    local AbsPos, AbsSize = Frame.AbsolutePosition, Frame.AbsoluteSize;
    if Pos.X >= AbsPos.X and Pos.X <= AbsPos.X + AbsSize.X
        and Pos.Y >= AbsPos.Y and Pos.Y <= AbsPos.Y + AbsSize.Y then
        return true;
    end;
end;

function Library:UpdateDependencyBoxes()
    for _, Depbox in next, Library.DependencyBoxes do
        Depbox:Update();
    end;
end;

function Library:MapValue(Value, MinA, MaxA, MinB, MaxB)
    return (1 - ((Value - MinA) / (MaxA - MinA))) * MinB + ((Value - MinA) / (MaxA - MinA)) * MaxB;
end;

function Library:GetTextBounds(Text, Font, Size, Resolution)
    local Bounds = TextService:GetTextSize(Text:gsub("<%/?[%w:]+[^>]*>", ""), Size, Font, Resolution or Vector2.new(1920, 1080))
    return Bounds.X, Bounds.Y
end;

function Library:GetDarkerColor(Color)
    local H, S, V = Color3.toHSV(Color);
    return Color3.fromHSV(H, S, V / 1.5);
end;
Library.AccentColorDark = Library:GetDarkerColor(Library.AccentColor);

function Library:AddToRegistry(Instance, Properties, IsHud)
    local Idx = #Library.Registry + 1;
    local Data = {
        Instance = Instance;
        Properties = Properties;
        Idx = Idx;
    };
    table.insert(Library.Registry, Data);
    Library.RegistryMap[Instance] = Data;
    if IsHud then
        table.insert(Library.HudRegistry, Data);
    end;
end;

function Library:RemoveFromRegistry(Instance)
    local Data = Library.RegistryMap[Instance];
    if Data then
        for Idx = #Library.Registry, 1, -1 do
            if Library.Registry[Idx] == Data then
                table.remove(Library.Registry, Idx);
            end;
        end;
        for Idx = #Library.HudRegistry, 1, -1 do
            if Library.HudRegistry[Idx] == Data then
                table.remove(Library.HudRegistry, Idx);
            end;
        end;
        Library.RegistryMap[Instance] = nil;
    end;
end;

function Library:UpdateColorsUsingRegistry()
    for Idx, Object in next, Library.Registry do
        for Property, ColorIdx in next, Object.Properties do
            if typeof(ColorIdx) == "string" then
                Object.Instance[Property] = Library[ColorIdx];
            elseif typeof(ColorIdx) == 'function' then
                Object.Instance[Property] = ColorIdx()
            end
        end;
    end;
end;

function Library:GiveSignal(Signal)
    table.insert(Library.Signals, Signal)
end

function Library:Unload()
    for Idx = #Library.Signals, 1, -1 do
        local Connection = table.remove(Library.Signals, Idx)
        Connection:Disconnect()
    end
    for _, UnloadCallback in pairs(Library.UnloadSignals) do
        Library:SafeCallback(UnloadCallback)
    end
    ScreenGui:Destroy()
    ModalScreenGui:Destroy()
    Library.Unloaded = true
    getgenv().Linoria = nil
end

function Library:OnUnload(Callback)
    table.insert(Library.UnloadSignals, Callback)
end

Library:GiveSignal(ScreenGui.DescendantRemoving:Connect(function(Instance)
    if Library.RegistryMap[Instance] then
        Library:RemoveFromRegistry(Instance);
    end;
end))

local function Trim(Text: string)
    return Text:match("^%s*(.-)%s*$")
end

-- Modern watermark design
local ModernWatermark = Library:CreateModern('Frame', {
    Name = "ModernWatermark",
    BackgroundColor3 = ModernColors.Primary,
    BorderSizePixel = 0,
    Position = UDim2.new(0, 10, 0, 10),
    Size = UDim2.new(0, 250, 0, 35),
    ZIndex = 200,
    Visible = false
})

local WatermarkGradient = Instance.new("UIGradient")
WatermarkGradient.Color = ColorSequence.new({
    ColorSequenceKeypoint.new(0, ModernColors.Accent),
    ColorSequenceKeypoint.new(1, ModernColors.AccentDark)
})
WatermarkGradient.Rotation = 45
WatermarkGradient.Parent = ModernWatermark

ApplyModernCorners(ModernWatermark, 8)
ApplyModernStroke(ModernWatermark, 2, ModernColors.Accent)

local WatermarkLabel = Library:CreateLabel({
    Position = UDim2.new(0, 12, 0, 0),
    Size = UDim2.new(1, -24, 1, 0),
    TextSize = 14,
    TextColor3 = ModernColors.Text,
    TextXAlignment = Enum.TextXAlignment.Left,
    ZIndex = 201,
    Parent = ModernWatermark
})

Library.Watermark = ModernWatermark
Library.WatermarkText = WatermarkLabel
Library:MakeDraggable(Library.Watermark)

-- Modern notification system
function Library:ModernNotify(...)
    local Data = { Steps = 1 }
    local Info = select(1, ...)

    if typeof(Info) == "table" then
        Data.Title = Info.Title and tostring(Info.Title) or ""
        Data.Description = tostring(Info.Description)
        Data.Time = Info.Time or 5
        Data.SoundId = Info.SoundId
        Data.Type = Info.Type or "Info"
    else
        Data.Title = ""
        Data.Description = tostring(Info)
        Data.Time = select(2, ...) or 5
        Data.SoundId = select(3, ...)
        Data.Type = "Info"
    end
    
    local Side = string.lower(Library.NotifySide)
    local XSize, YSize = Library:GetTextBounds(Data.Description, Library.Font, 14)
    YSize = YSize + 20

    local typeColors = {
        Info = ModernColors.Accent,
        Success = ModernColors.Success,
        Warning = ModernColors.Warning,
        Error = ModernColors.Error
    }
    local accentColor = typeColors[Data.Type] or ModernColors.Accent

    local NotifyOuter = Library:CreateModern('Frame', {
        BackgroundColor3 = ModernColors.Primary,
        Size = UDim2.new(0, 0, 0, YSize),
        ClipsDescendants = true,
        ZIndex = 100,
        Parent = if Side == "left" then Library.LeftNotificationArea else Library.RightNotificationArea,
        CornerRadius = 8
    })

    ApplyModernStroke(NotifyOuter, 2, accentColor)

    local Icon = Library:Create('ImageLabel', {
        BackgroundTransparency = 1,
        Position = UDim2.new(0, 8, 0, 8),
        Size = UDim2.new(0, 16, 0, 16),
        Image = "rbxassetid://6031091007",
        ImageColor3 = accentColor,
        ZIndex = 102,
        Parent = NotifyOuter
    })

    local NotifyLabel = Library:CreateLabel({
        Position = UDim2.new(0, 32, 0, 8),
        Size = UDim2.new(1, -40, 1, -16),
        Text = (if Data.Title == "" then "" else "<b>" .. Data.Title .. "</b>\n") .. tostring(Data.Description),
        TextXAlignment = Enum.TextXAlignment.Left,
        TextYAlignment = Enum.TextYAlignment.Top,
        TextSize = 13,
        RichText = true,
        ZIndex = 102,
        Parent = NotifyOuter
    })

    local ProgressBar = Library:CreateModern('Frame', {
        BackgroundColor3 = accentColor,
        Position = UDim2.new(0, 0, 1, -3),
        Size = UDim2.new(1, 0, 0, 3),
        ZIndex = 103,
        Parent = NotifyOuter,
        CornerRadius = 0
    })

    function Data:Resize()
        XSize, YSize = Library:GetTextBounds(NotifyLabel.Text, Library.Font, 13)
        YSize = math.max(YSize + 20, 50)
        pcall(NotifyOuter.TweenSize, NotifyOuter, UDim2.new(0, math.min(XSize * DPIScale + 48, 400), 0, YSize), 'Out', 'Quad', 0.3, true)
    end

    Data:Resize()

    local progressTween = TweenService:Create(ProgressBar, TweenInfo.new(Data.Time, Enum.EasingStyle.Linear), {
        Size = UDim2.new(0, 0, 0, 3)
    })
    progressTween:Play()

    if Data.SoundId then
        Library:Create('Sound', {
            SoundId = "rbxassetid://" .. tostring(Data.SoundId):gsub("rbxassetid://", ""),
            Volume = 2,
            PlayOnRemove = true,
            Parent = game:GetService("SoundService")
        }):Destroy()
    end

    task.spawn(function()
        if typeof(Data.Time) == "Instance" then
            Data.Time.Destroying:Wait()
        else
            task.wait(Data.Time or 5)
        end

        local fadeTween = TweenService:Create(NotifyOuter, TweenInfo.new(0.3, Enum.EasingStyle.Quad), {
            BackgroundTransparency = 1,
            Size = UDim2.new(0, 0, 0, YSize)
        })
        fadeTween:Play()
        task.wait(0.3)
        NotifyOuter:Destroy()
    end)

    return Data
end

Library.Notify = Library.ModernNotify

-- Modern keybind frame
local ModernKeybindFrame = Library:CreateModern('Frame', {
    Name = "ModernKeybindFrame",
    BackgroundColor3 = ModernColors.Primary,
    BorderSizePixel = 0,
    Position = UDim2.new(0, 10, 0.5, -100),
    Size = UDim2.new(0, 220, 0, 30),
    Visible = false,
    ZIndex = 100,
    CornerRadius = 8
})

ApplyModernStroke(ModernKeybindFrame, 2, ModernColors.Accent)

local KeybindHeader = Library:CreateLabel({
    Position = UDim2.new(0, 12, 0, 0),
    Size = UDim2.new(1, -24, 0, 30),
    Text = "KEYBINDS",
    TextSize = 14,
    TextColor3 = ModernColors.Accent,
    TextXAlignment = Enum.TextXAlignment.Left,
    ZIndex = 101,
    Parent = ModernKeybindFrame
})

local ModernKeybindContainer = Library:Create('Frame', {
    BackgroundTransparency = 1,
    Position = UDim2.new(0, 0, 0, 30),
    Size = UDim2.new(1, 0, 1, -30),
    ZIndex = 100,
    Parent = ModernKeybindFrame
})

Library:Create('UIListLayout', {
    FillDirection = Enum.FillDirection.Vertical,
    SortOrder = Enum.SortOrder.LayoutOrder,
    Parent = ModernKeybindContainer
})

Library.KeybindFrame = ModernKeybindFrame
Library.KeybindContainer = ModernKeybindContainer
Library:MakeDraggable(Library.KeybindFrame)

-- Update color registry for modern theme
Library:AddToRegistry(ModernKeybindFrame, {
    BackgroundColor3 = 'Primary'
})

-- Rest of the original code remains the same but will use modern styling...
-- [The rest of your original code continues here with modern styling applied...]

-- Replace original create window with modern version
local originalCreateWindow = Library.CreateWindow
function Library:CreateModernWindow(Config)
    local window = originalCreateWindow(self, Config)
    
    -- Apply modern styling to window
    local Outer = window.Holder
    local Inner = Outer:FindFirstChildWhichIsA("Frame")
    
    if Inner then
        ApplyModernCorners(Outer, 12)
        ApplyModernStroke(Outer, 2, ModernColors.Accent)
        
        -- Update inner frame
        Inner.BackgroundColor3 = ModernColors.Primary
        Inner.BorderColor3 = ModernColors.Accent
        
        -- Modernize tab buttons
        for _, child in pairs(Inner:GetDescendants()) do
            if child:IsA("Frame") and child.Name == "TabButton" then
                ApplyModernCorners(child, 6)
                ApplyModernStroke(child, 1)
                
                child.BackgroundColor3 = ModernColors.Secondary
                child.BorderColor3 = ModernColors.Border
            end
        end
    end
    
    return window
end

Library.CreateWindow = Library.CreateModernWindow

if getgenv().skip_getgenv_linoria ~= true then getgenv().Library = Library end
return Library
